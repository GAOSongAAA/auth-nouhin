# 统一认证授权中心设计方案 (参考 Sa-Token)

## 1. 概要

本文档旨在为项目设计一套统一的、可扩展的认证与授权(Authentication & Authorization)解决方案。该方案将深度参考 [Sa-Token](https://github.com/GAOSongAAA/Sa-Token) 的设计理念，结合项目现有的 `common` 模块，实现一个灵活、安全、易于维护的权限控制体系。

核心目标是根据请求头中的 `Authorization-Type` 字段，动态地采用不同的认证策略（如：`database` 数据库认证、`oauth2` 开放授权），并在认证通过后，通过拦截器进行统一的路由级别权限校验。

## 2. 设计理念

本方案遵循以下核心设计原则：

1.  **责任链模式 (Chain of Responsibility)**：请求将通过一个明确的、可配置的处理链：`Global Filter` -> `Authentication Strategy` -> `Authorization Interceptor` -> `Controller`。每一层各司其职，提高了系统的模块化和可维护性。
2.  **认证与授权分离**：
    *   **认证 (Authentication)**：在 `Filter` 层完成，仅负责确认“你是谁”。根据不同策略（`database`, `oauth2`），验证用户身份的合法性，并生成统一的会话（如 `Auth_Token`）。
    *   **授权 (Authorization)**：在 `Interceptor` 层完成，负责判断“你能做什么”。在确认用户身份后，根据用户的角色和权限，决定其是否有权访问目标路由（Controller 方法）。
3.  **策略模式 (Strategy Pattern)**：针对 `database` 和 `oauth2` 等多种认证方式，我们不使用冗长的 `if-else` 判断，而是抽象出一个 `AuthenticationStrategy` 接口。每种认证方式都是该接口的一个具体实现，由一个主过滤器根据 `Authorization-Type` 的值动态选择和执行，极大地提高了系统的灵活性和扩展性。
4.  **无状态 Token**：前后端交互完全依赖 `Auth_Token` (JWT)，服务器本身不存储会话状态。这使得系统更易于水平扩展。Token 的校验和续期将是认证过程的核心部分。
5.  **配置化与自动化**：权限规则（哪个角色可以访问哪个路由）和认证参数应尽可能配置化。利用 Spring Boot 的自动装配机制，将各个组件（Filter, Interceptor, Strategy）无缝集成到应用中。

## 3. 核心组件设计

我们将基于您现有的 `common` 模块进行扩展和实现。

### 3.1. `AuthenticationFilter` (全局认证过滤器)

这是整个认证授权体系的入口。我们将利用或改造现有的 `AuthServletFilter`。

-   **文件位置**: `com.collaboportal.common.filter.AuthServletFilter`
-   **核心职责**:
    1.  **前置处理**: 在 `doFilter` 方法中，首先执行所有请求都需经过的逻辑（如日志记录、IP分析等）。
    2.  **策略选择**: 从请求头中提取 `Authorization-Type` 的值。
    3.  **策略执行**: 根据 `Authorization-Type` 的值，从 `AuthenticationStrategyRegistry` (策略注册中心) 中获取对应的认证策略实例。
    4.  **委托认证**: 调用策略实例的 `authenticate()` 方法，将认证的具体逻辑委托给它。
    5.  **异常捕获**: 统一捕获认证过程中抛出的异常（如 `TokenExpiredException`, `AuthenticationException`），并返回标准格式的错误响应或执行重定向。

**伪代码实现:**

```java
// In AuthServletFilter.java
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
    try {
        // 1. 获取 Request & Response 对象
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse res = (HttpServletResponse) response;

        // 2. 从 Header 中获取认证类型
        String authType = req.getHeader("Authorization-Type");
        if (authType == null || authType.isEmpty()) {
            // 如果是需要认证的接口，但没有提供类型，则直接拒绝
            // ... 返回 401 错误
            return;
        }

        // 3. 从策略注册中心获取对应策略
        AuthenticationStrategy strategy = strategyRegistry.getStrategy(authType);
        if (strategy == null) {
            // ... 返回 400 错误，不支持的认证类型
            return;
        }

        // 4. 执行认证
        strategy.authenticate(req, res);

        // 5. 认证成功，放行到下一个 Filter 或 Interceptor
        chain.doFilter(request, response);

    } catch (RedirectException re) {
        // 捕获重定向异常
        res.sendRedirect(re.getRedirectUrl());
    } catch (AuthenticationException ae) {
        // 捕获认证失败异常
        res.setStatus(401);
        res.getWriter().write(buildErrorResponse(401, ae.getMessage()));
    } catch (Exception e) {
        // 其他异常
        res.setStatus(500);
        res.getWriter().write(buildErrorResponse(500, "Internal Server Error"));
    }
}
```

### 3.2. `AuthenticationStrategy` (认证策略接口与实现)

这是策略模式的核心，定义了所有认证方式必须遵守的契约。

-   **接口位置**: `com.collaboportal.common.strategy.auth.AuthenticationStrategy`
-   **接口定义**:

    ```java
    @FunctionalInterface
    public interface AuthenticationStrategy {
        /**
         * 执行认证逻辑
         * @param request  HttpServletRequest
         * @param response HttpServletResponse
         * @throws AuthenticationException 如果认证失败
         * @throws RedirectException 如果需要重定向
         */
        void authenticate(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, RedirectException;
    }
    ```

#### 3.2.1. `DatabaseAuthStrategy` (数据库认证策略)

-   **文件位置**: `com.collaboportal.common.strategy.auth.DatabaseAuthStrategy`
-   **核心职责**:
    1.  从 Cookie 中获取 `Auth_Token`。
    2.  如果 Token 不存在或为空，直接抛出 `RedirectException`，重定向到登录页面。
    3.  使用 `JwtTokenUtil` 校验 Token 的签名和时效性。
    4.  如果 Token 无效（如过期），同样抛出 `RedirectException`。
    5.  如果 Token 有效，解析出用户信息（如 userId, roles），并将其存入 `CommonHolder.getStorage()` 中，供后续的 `AuthorizationInterceptor` 使用。
    6.  刷新 Token 的有效期，并将新的 Token 写回 Response 的 Cookie 中。

#### 3.2.2. `OAuth2AuthStrategy` (OAuth2 认证策略)

-   **文件位置**: `com.collaboportal.common.strategy.auth.OAuth2AuthStrategy`
-   **核心职责**:
    1.  从 Cookie 中获取 `Auth_Token`。
    2.  如果 Token 存在且有效（通过 `JwtTokenUtil` 校验），则流程与 `DatabaseAuthStrategy` 的第 5、6 步相同，刷新并放行。
    3.  如果 Token 不存在或无效，则触发 OAuth2 认证流程。
    4.  这需要重用您在 `common-oauth2` 模块中已有的逻辑，构造出 OAuth2 提供商的授权 URL（`buildAuthRedirectUrl`），并抛出 `RedirectException`，将用户重定向到该 URL 进行授权。
    5.  OAuth2 的回调逻辑 (`/auth/callback`) 将独立处理，它负责接收 `code` 和 `state`，换取 Access Token，获取用户信息，最终生成我们系统自己的 `Auth_Token` 并写入 Cookie，然后重定向回最初访问的页面。

### 3.3. `AuthenticationStrategyRegistry` (策略注册中心)

这是一个简单的服务类，用于在应用启动时注册所有可用的 `AuthenticationStrategy` 实现，并在运行时根据 `authType` 提供对应的实例。

-   **文件位置**: `com.collaboportal.common.registry.AuthenticationStrategyRegistry`
-   **核心职责**:
    *   内部使用一个 `Map<String, AuthenticationStrategy>` 来存储策略。
    *   提供 `register(String authType, AuthenticationStrategy strategy)` 方法。
    *   提供 `getStrategy(String authType)` 方法。
-   **实现方式**:
    *   在 Spring 的配置类中，将所有 `AuthenticationStrategy` 的 Bean 注入一个 Map，并自动完成注册。

### 3.4. `AuthorizationInterceptor` (路由权限拦截器)

当 `AuthenticationFilter` 成功认证后，请求将进入此拦截器进行最终的权限校验。

-   **文件位置**: `com.collaboportal.common.interceptor.AuthInterceptor`
-   **核心职责**:
    1.  在 `preHandle` 方法中执行逻辑。
    2.  从 `CommonHolder.getStorage()` 中获取由认证策略存入的用户信息（特别是用户角色 `roles`）。
    3.  获取当前请求的 Controller 方法（`HandlerMethod`），并从中解析出需要的权限注解（例如，我们可以自定义一个 `@RequiresRole("admin")` 注解）。
    4.  **权限匹配**：检查用户的角色列表是否包含注解中要求的角色。
    5.  如果权限匹配成功，返回 `true`，请求继续流向 Controller。
    6.  如果权限匹配失败，直接返回 `false`，并设置 HTTP 响应状态为 `401` 或 `403`，请求被中断。

**伪代码实现:**

```java
// In AuthInterceptor.java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    // 检查 handler 是否为 Controller 方法
    if (!(handler instanceof HandlerMethod)) {
        return true; // 不是方法请求，直接放行
    }

    // 1. 获取方法上的权限注解
    HandlerMethod handlerMethod = (HandlerMethod) handler;
    RequiresRole requiresRole = handlerMethod.getMethodAnnotation(RequiresRole.class);

    // 2. 如果方法没有权限注解，直接放行
    if (requiresRole == null) {
        return true;
    }

    // 3. 从请求上下文中获取用户信息
    UserInfo userInfo = (UserInfo) CommonHolder.getStorage().get("USER_INFO");
    if (userInfo == null || userInfo.getRoles() == null) {
        response.setStatus(401); // 未认证或信息丢失
        return false;
    }

    // 4. 权限校验
    String requiredRole = requiresRole.value();
    if (userInfo.getRoles().contains(requiredRole)) {
        return true; // 拥有权限，放行
    } else {
        response.setStatus(403); // 禁止访问
        return false;
    }
}
```

## 4. 完整处理流程

1.  **请求到达**: 客户端发起一个 API 请求，并在 Header 中携带 `Authorization-Type: database` 和 Cookie `Auth_Token=xxxx`。
2.  **`AuthenticationFilter` 介入**:
    *   过滤器获取到 `Authorization-Type` 为 `database`。
    *   从 `AuthenticationStrategyRegistry` 中找到 `DatabaseAuthStrategy` 实例。
    *   调用 `strategy.authenticate()`。
3.  **`DatabaseAuthStrategy` 执行**:
    *   从 Cookie 中读取 `Auth_Token`。
    *   使用 `JwtTokenUtil.isTokenExpired()` 等方法校验 Token。
    *   校验通过，解析 Token 获取 `userId` 和 `roles`。
    *   将用户信息存入 `CommonHolder.getStorage().set("USER_INFO", userInfo)`。
    *   刷新 Token，并通过 `response.addCookie()` 将新 Token 发送给客户端。
    *   认证成功，方法正常返回。
4.  **请求流转**:
    *   `AuthenticationFilter` 捕获到无异常，调用 `chain.doFilter()`，请求继续向后传递。
5.  **`AuthorizationInterceptor` 介入**:
    *   拦截器 `preHandle` 方法被触发。
    *   从 `CommonHolder.getStorage()` 中取出 `USER_INFO`。
    *   检查目标 Controller 方法上的 `@RequiresRole("some_role")` 注解。
    *   对比用户的角色和方法要求的角色。
    *   假设角色匹配，`preHandle` 返回 `true`。
6.  **请求到达 Controller**:
    *   Controller 方法被执行，处理业务逻辑并返回结果。

---

**场景：Token 过期或未登录**

*   在上述流程的第 3 步，如果 `DatabaseAuthStrategy` 发现 Token 不存在或已过期，它会直接抛出一个 `RedirectException("/login")`。
*   `AuthenticationFilter` 的 `catch` 块捕获此异常，并调用 `response.sendRedirect("/login")`，将用户重定向到登录页。整个请求处理链在此中断。

**场景：OAuth2 认证**

*   在上述流程的第 2 步，如果 `Authorization-Type` 是 `oauth2`，则会选择 `OAuth2AuthStrategy`。
*   在第 3 步，如果 `Auth_Token` 无效，`OAuth2AuthStrategy` 会构造一个指向第三方授权页面的 URL，并抛出 `RedirectException`，后续流程与 Token 过期类似，但重定向目标是 OAuth2 授权页。

## 5. 总结

该设计方案为您提供了一个强大且灵活的认证授权框架。它不仅满足了您提出的所有功能点，而且借鉴了 Sa-Token 的优秀设计思想，使得未来的功能扩展（如增加新的认证方式、更复杂的权限模型等）变得简单。通过复用您现有的 `common` 模块，可以以最小的成本实现这套高级功能。
